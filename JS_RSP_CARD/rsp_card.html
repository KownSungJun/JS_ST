<!doctype html>
<html lang="ko">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>가위바위보 카드 배치 게임</title>
    <style>
        :root {
            --bg: #0f172a;
            --card: #f8fafc;
            --muted: #94a3b8;
            --accent: #60a5fa;
            --win: #10b981;
            --lose: #ef4444;
            --tie: #f59e0b;
        }

        body {
            margin: 0;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(180deg, var(--bg), #071025);
            font-family: Inter, "Noto Sans KR", system-ui, -apple-system, "Segoe UI", Roboto;
            color: var(--card);
            padding: 20px;
            box-sizing: border-box;
        }

        .container {
            width: 100%;
            max-width: 920px;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.03), rgba(255, 255, 255, 0.01));
            border-radius: 12px;
            box-shadow: 0 8px 30px rgba(2, 6, 23, 0.7);
            padding: 20px;
        }

        h1 {
            margin: 0 0 12px 0;
            font-size: 20px;
        }

        p.lead {
            margin: 0 0 18px 0;
            color: var(--muted);
        }

        .board {
            display: grid;
            grid-template-rows: auto auto auto;
            gap: 14px;
        }

        /* 슬롯 행 (대칭: 적 / 중간 라인(번호) / 플레이어) */
        .row {
            display: flex;
            gap: 12px;
            align-items: center;
            justify-content: center;
        }

        .slot {
            width: 140px;
            height: 90px;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.03);
            border: 2px dashed rgba(255, 255, 255, 0.06);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            transition: transform .12s ease, box-shadow .12s ease;
            user-select: none;
        }

        .slot[data-side="top"] {
            transform: rotateX(10deg);
        }

        .slot[data-side="bottom"] {
            transform: rotateX(-6deg);
        }

        .slot.drag-over {
            box-shadow: 0 6px 20px rgba(96, 165, 250, 0.12);
            border-color: rgba(96, 165, 250, 0.6);
            transform: translateY(-6px);
        }

        .slot .card-in-slot {
            text-align: center;
        }

        .slot .result-badge {
            position: absolute;
            right: 6px;
            top: 6px;
            padding: 4px 8px;
            border-radius: 999px;
            font-weight: 700;
            font-size: 13px;
            display: none;
        }

        .slot.win .result-badge {
            display: block;
            background: var(--win);
            color: white;
        }

        .slot.lose .result-badge {
            display: block;
            background: var(--lose);
            color: white;
        }

        .slot.tie .result-badge {
            display: block;
            background: var(--tie);
            color: white;
        }

        /* 카드 팔레트 */
        .palette {
            margin-top: 16px;
            display: flex;
            gap: 10px;
            justify-content: center;
            align-items: center;
        }

        .card {
            width: 120px;
            height: 70px;
            border-radius: 10px;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.98), rgba(255, 255, 255, 0.95));
            color: #0b1220;
            font-weight: 700;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: grab;
            user-select: none;
            box-shadow: 0 6px 18px rgba(2, 6, 23, 0.4);
        }

        .card:active {
            cursor: grabbing;
        }

        .controls {
            margin-top: 18px;
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        button {
            background: var(--accent);
            border: none;
            padding: 8px 14px;
            color: white;
            font-weight: 700;
            border-radius: 8px;
            cursor: pointer;
        }

        button.secondary {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.08);
            color: var(--card);
        }

        .scoreboard {
            display: flex;
            justify-content: center;
            gap: 18px;
            margin-top: 10px;
            color: var(--muted);
            font-weight: 700;
        }

        /* 모바일 대응 */
        @media (max-width:640px) {
            .slot {
                width: 92px;
                height: 72px;
            }

            .card {
                width: 84px;
                height: 56px;
                font-size: 14px;
            }
        }
    </style>
</head>

<body>
    <div class="container" role="application" aria-label="가위바위보 카드 배치 게임">
        <h1>가위·바위·보 카드 배치 (대칭 보드)</h1>
        <p class="lead">카드(가위/바위/보)를 아래 슬롯에 놓으세요. 상대(컴퓨터)는 슬롯 수만큼 랜덤 배치합니다. 모두 배치 후 결과가 표시됩니다. 드래그 & 드롭 또는 터치/클릭으로
            사용하세요.</p>

        <div class="board" id="board" aria-live="polite">
            <!-- 적(상단) -->
            <div class="row" id="opponentRow" aria-label="상대 슬롯">
                <!-- slots generated by JS -->
            </div>

            <!-- 중앙 슬롯 라벨 -->
            <div class="row" style="pointer-events:none;">
                <div style="width:140px; text-align:center; color:var(--muted)">1</div>
                <div style="width:140px; text-align:center; color:var(--muted)">2</div>
                <div style="width:140px; text-align:center; color:var(--muted)">3</div>
            </div>

            <!-- 플레이어(하단) -->
            <div class="row" id="playerRow" aria-label="플레이어 슬롯">
                <!-- slots generated by JS -->
            </div>
        </div>

        <div class="palette" id="palette" aria-label="카드 팔레트">
            <div class="card" draggable="true" data-type="rock" tabindex="0">바위 ✊</div>
            <div class="card" draggable="true" data-type="paper" tabindex="0">보 ✋</div>
            <div class="card" draggable="true" data-type="scissors" tabindex="0">가위 ✌️</div>
        </div>

        <div class="controls">
            <button id="revealBtn">결과 보기</button>
            <button class="secondary" id="resetBtn">초기화</button>
        </div>

        <div class="scoreboard" id="scoreboard" aria-label="점수판">
            <div>플레이어: <span id="playerScore">0</span></div>
            <div>무승부: <span id="tieScore">0</span></div>
            <div>상대: <span id="opponentScore">0</span></div>
        </div>
    </div>

    <script>
        (() => {
            const cols = 3; // 슬롯 수 (대칭)
            const opponentRow = document.getElementById('opponentRow');
            const playerRow = document.getElementById('playerRow');
            const palette = document.getElementById('palette');
            const revealBtn = document.getElementById('revealBtn');
            const resetBtn = document.getElementById('resetBtn');
            const playerScoreEl = document.getElementById('playerScore');
            const opponentScoreEl = document.getElementById('opponentScore');
            const tieScoreEl = document.getElementById('tieScore');

            let selectedCardType = null; // 클릭으로 선택된 카드(모바일)
            let scores = { player: 0, opponent: 0, tie: 0 };

            // 유틸: 랜덤 카드
            const types = ['rock', 'paper', 'scissors'];
            const typeToLabel = { rock: '바위 ✊', paper: '보 ✋', scissors: '가위 ✌️' };

            // 초기 슬롯 생성
            function createSlots() {
                opponentRow.innerHTML = '';
                playerRow.innerHTML = '';
                for (let i = 0; i < cols; i++) {
                    const opp = makeSlot(i, 'top');
                    const ply = makeSlot(i, 'bottom');
                    opponentRow.appendChild(opp);
                    playerRow.appendChild(ply);
                }
            }

            // 슬롯 요소 생성
            function makeSlot(index, side) {
                const slot = document.createElement('div');
                slot.className = 'slot';
                slot.dataset.index = index;
                slot.dataset.side = side;
                slot.tabIndex = 0;
                slot.setAttribute('aria-label', `${side === 'top' ? '상대' : '플레이어'} 슬롯 ${index + 1}`);
                slot.innerHTML = `<div class="card-in-slot" aria-hidden="true"></div><div class="result-badge"></div>`;

                // 드래그 이벤트 (플레이어 슬롯에만 카드 놓을 수 있음)
                if (side === 'bottom') {
                    slot.addEventListener('dragover', ev => { ev.preventDefault(); slot.classList.add('drag-over'); });
                    slot.addEventListener('dragleave', ev => { slot.classList.remove('drag-over'); });
                    slot.addEventListener('drop', ev => {
                        ev.preventDefault();
                        slot.classList.remove('drag-over');
                        const type = ev.dataTransfer.getData('text/plain');
                        if (type) placeCardInSlot(slot, type);
                    });

                    // 클릭/터치로도 카드 배치 (모바일)
                    slot.addEventListener('click', () => {
                        if (selectedCardType) {
                            placeCardInSlot(slot, selectedCardType);
                            // 선택 해제(모바일 UX)
                            selectedCardType = null;
                            document.querySelectorAll('.card').forEach(c => c.classList.remove('selected'));
                        }
                    });
                }

                return slot;
            }

            // 팔레트 카드 설정 (드래그 시작과 클릭 선택)
            palette.querySelectorAll('.card').forEach(card => {
                card.addEventListener('dragstart', ev => {
                    ev.dataTransfer.setData('text/plain', card.dataset.type);
                });

                // 키보드 접근성: Enter/Space로 선택
                card.addEventListener('keydown', ev => {
                    if (ev.key === 'Enter' || ev.key === ' ') {
                        ev.preventDefault();
                        selectPaletteCard(card);
                    }
                });

                // 클릭/터치로 선택 (모바일)
                card.addEventListener('click', () => selectPaletteCard(card));
            });

            function selectPaletteCard(cardEl) {
                document.querySelectorAll('.card').forEach(c => c.classList.remove('selected'));
                if (selectedCardType === cardEl.dataset.type) {
                    // 다시 누르면 해제
                    selectedCardType = null;
                } else {
                    selectedCardType = cardEl.dataset.type;
                    cardEl.classList.add('selected');
                }
            }

            // 카드 배치 함수: 플레이어 슬롯에 배치, 슬롯 이미 있으면 교체
            function placeCardInSlot(slotEl, type) {
                const idx = slotEl.dataset.index;
                const playerDiv = slotEl.querySelector('.card-in-slot');
                playerDiv.textContent = typeToLabel[type];
                playerDiv.dataset.type = type;
                playerDiv.style.opacity = '1';
                // 자동으로 상대 슬롯에 랜덤 배치 (대칭성 유지)
                const oppSlot = opponentRow.querySelector(`.slot[data-index="${idx}"]`);
                if (oppSlot) {
                    // 상대가 이미 있으면 유지하지 않고 새로 배치(게임 규칙에 따라 바꿔도 됨)
                    if (!oppSlot.querySelector('.card-in-slot').dataset.type) {
                        const randType = types[Math.floor(Math.random() * types.length)];
                        oppSlot.querySelector('.card-in-slot').textContent = typeToLabel[randType];
                        oppSlot.querySelector('.card-in-slot').dataset.type = randType;
                    }
                }
                // 자동으로 결과판단 (해당 칸 상대도 채워져 있으면)
                if (oppSlot && oppSlot.querySelector('.card-in-slot').dataset.type) {
                    evaluateSlot(idx);
                }
            }

            // RPS 결과 판단: 플레이어(bottom) vs 상대(top)
            function rpsResult(playerType, oppType) {
                if (playerType === oppType) return 'tie';
                if (
                    (playerType === 'rock' && oppType === 'scissors') ||
                    (playerType === 'paper' && oppType === 'rock') ||
                    (playerType === 'scissors' && oppType === 'paper')
                ) return 'player';
                return 'opponent';
            }

            // 한 슬롯 평가(색 표시 및 점수 집계) — 중복 평가 방지
            function evaluateSlot(index) {
                const pSlot = playerRow.querySelector(`.slot[data-index="${index}"]`);
                const oSlot = opponentRow.querySelector(`.slot[data-index="${index}"]`);
                const pType = pSlot.querySelector('.card-in-slot').dataset.type;
                const oType = oSlot.querySelector('.card-in-slot').dataset.type;
                if (!pType || !oType) return;

                // 이미 평가되었는지 확인 (result-badge가 있으면 이미 평가)
                if (pSlot.classList.contains('evaluated')) return;
                pSlot.classList.add('evaluated');
                oSlot.classList.add('evaluated');

                const res = rpsResult(pType, oType);
                if (res === 'tie') {
                    pSlot.classList.add('tie');
                    oSlot.classList.add('tie');
                    pSlot.querySelector('.result-badge').textContent = '무';
                    oSlot.querySelector('.result-badge').textContent = '무';
                    scores.tie++;
                } else if (res === 'player') {
                    pSlot.classList.add('win');
                    oSlot.classList.add('lose');
                    pSlot.querySelector('.result-badge').textContent = '승';
                    oSlot.querySelector('.result-badge').textContent = '패';
                    scores.player++;
                } else {
                    pSlot.classList.add('lose');
                    oSlot.classList.add('win');
                    pSlot.querySelector('.result-badge').textContent = '패';
                    oSlot.querySelector('.result-badge').textContent = '승';
                    scores.opponent++;
                }
                updateScoreboard();
            }

            function updateScoreboard() {
                playerScoreEl.textContent = scores.player;
                opponentScoreEl.textContent = scores.opponent;
                tieScoreEl.textContent = scores.tie;
            }

            // 결과 보기 버튼: 비어있는 상대 슬롯 채우고 모든 칸 평가
            revealBtn.addEventListener('click', () => {
                // 상대 빈칸 랜덤 채우기
                opponentRow.querySelectorAll('.slot').forEach(slot => {
                    const div = slot.querySelector('.card-in-slot');
                    if (!div.dataset.type) {
                        const randType = types[Math.floor(Math.random() * types.length)];
                        div.textContent = typeToLabel[randType];
                        div.dataset.type = randType;
                    }
                });

                // 플레이어 빈칸은 '없음'으로 채우지 않고 평가 불가
                for (let i = 0; i < cols; i++) {
                    const pSlot = playerRow.querySelector(`.slot[data-index="${i}"]`);
                    const oSlot = opponentRow.querySelector(`.slot[data-index="${i}"]`);
                    const pType = pSlot.querySelector('.card-in-slot').dataset.type;
                    const oType = oSlot.querySelector('.card-in-slot').dataset.type;
                    if (pType && oType && !pSlot.classList.contains('evaluated')) {
                        evaluateSlot(i);
                    }
                }
            });

            // 초기화
            resetBtn.addEventListener('click', resetAll);

            function resetAll() {
                scores = { player: 0, opponent: 0, tie: 0 };
                updateScoreboard();
                selectedCardType = null;
                document.querySelectorAll('.card').forEach(c => c.classList.remove('selected'));
                createSlots();
            }

            // 처음 생성
            createSlots();

            // 접근성/키보드: 슬롯 포커스 후 Enter로 결과 확인(플레이어 슬롯에 카드가 선택된 상태)
            playerRow.addEventListener('keydown', ev => {
                if ((ev.key === 'Enter' || ev.key === ' ') && selectedCardType) {
                    const focused = document.activeElement;
                    if (focused && focused.classList.contains('slot')) {
                        placeCardInSlot(focused, selectedCardType);
                    }
                }
            });

            // 모바일에서 드래그 불가하면 클릭으로만 동작하게 하기 위해서 기본 스타일 추가
            // (브라우저들이 드래그 이벤트를 지원하므로 추가 처리 불필요)
        })();
    </script>
</body>

</html>